/*
Copyright 2018 The OpenEBS Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package smart

import (
	"bytes"
	"encoding/binary"
	"testing"

	"github.com/openebs/node-disk-manager/pkg/util"
	"github.com/stretchr/testify/assert"
)

// mock data of ata command set page
var ataCSPage = [512]byte{
	0x7a, 0x42, 0xff, 0x3f, 0x37, 0xc8, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x20, 0x20, 0x57, 0x20, 0x2d, 0x44,
	0x58, 0x57, 0x31, 0x33, 0x42, 0x41, 0x35, 0x37, 0x53, 0x38, 0x30, 0x32, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x33, 0x30, 0x30, 0x2e, 0x41, 0x31, 0x33, 0x30, 0x44, 0x57,
	0x20, 0x43, 0x44, 0x57, 0x30, 0x31, 0x50, 0x53, 0x58, 0x5a, 0x30, 0x2d, 0x5a, 0x38,
	0x30, 0x31, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x10, 0x80, 0x00, 0x40,
	0x00, 0x2f, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0xff, 0x3f, 0x10, 0x00,
	0x3f, 0x00, 0x10, 0xfc, 0xfb, 0x00, 0x10, 0x01, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00,
	0x07, 0x00, 0x03, 0x00, 0x78, 0x00, 0x78, 0x00, 0x78, 0x00, 0x78, 0x00, 0x08, 0x4d,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x0e, 0x9d,
	0x06, 0x00, 0x4c, 0x00, 0x44, 0x00, 0xfe, 0x07, 0x6d, 0x00, 0x6b, 0x30, 0x09, 0x74,
	0x23, 0x61, 0x69, 0x30, 0x09, 0xb4, 0x23, 0x61, 0x7f, 0x40, 0x58, 0x00, 0x58, 0x00,
	0x80, 0x00, 0xfe, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xb0, 0x6d, 0x70, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0a, 0x00, 0x03, 0x60, 0x00, 0x00, 0x01, 0x50, 0xe6, 0x4e, 0x95, 0x5d, 0xdf, 0x09,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1c, 0x40, 0x1c, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x10, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb0, 0x6d,
	0x70, 0x74, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa5, 0x35,
}

var d ATACSPage // ATACSPage struct used for parsing ATA Command set page

func TestSwapByteOrder(t *testing.T) {
	serialNumArray := []byte{32, 32, 32, 32, 87, 32, 45, 68, 88, 87, 49, 51, 66, 65, 53, 55, 83, 56, 48, 50}
	swappedSerialNum := []byte{32, 32, 32, 32, 32, 87, 68, 45, 87, 88, 51, 49, 65, 66, 55, 53, 56, 83, 50, 48}

	tests := map[string]struct {
		inputByteArray []byte
		expected       []byte
	}{
		"Get swapped byte array for serialNumArray": {inputByteArray: serialNumArray, expected: swappedSerialNum},
	}
	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			assert.Equal(t, test.expected, d.swapByteOrder(test.inputByteArray))
		})
	}
}

func TestGetSerialNumber(t *testing.T) {
	SerialNum := "     WD-WX31AB758S20"

	binary.Read(bytes.NewBuffer(ataCSPage[:]), util.NativeEndian, &d)

	tests := map[string]struct {
		expected string
	}{
		"Check serial number assuming d.SerialNumber as raw SerialNum from ATA CS page": {expected: SerialNum},
	}
	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			assert.Equal(t, test.expected, string(d.getSerialNumber()))
		})
	}
}

func TestGetWWN(t *testing.T) {
	expectedWWN := "5 0014ee 65d9509df"

	binary.Read(bytes.NewBuffer(ataCSPage[:]), util.NativeEndian, &d)

	tests := map[string]struct {
		expected string
	}{
		"Check WWN number assuming d.WWN as raw WWN from ATA CS page": {expected: expectedWWN},
	}
	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			assert.Equal(t, test.expected, d.getWWN())
		})
	}
}

func TestGetSectorSize(t *testing.T) {
	const PBSize uint32 = 4096
	const LBSize uint32 = 512

	binary.Read(bytes.NewBuffer(ataCSPage[:]), util.NativeEndian, &d)

	tests := map[string]struct {
		expectedPBSize uint32
		expectedLBSize uint32
	}{
		"get sector sizes assuming d.SectorSize as raw sector size from ATACS page": {expectedPBSize: PBSize, expectedLBSize: LBSize},
	}
	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			ActualLBSize, ActualPBSize := d.getSectorSize()
			assert.Equal(t, test.expectedPBSize, ActualPBSize)
			assert.Equal(t, test.expectedLBSize, ActualLBSize)
		})
	}
}

func TestGetATAMajorVersion(t *testing.T) {
	expectedATAMajorVer := "ACS-3"

	binary.Read(bytes.NewBuffer(ataCSPage[:]), util.NativeEndian, &d)

	tests := map[string]struct {
		expected string
	}{
		"get ata major version assuming d.MajorVer as raw data from ATACS page": {expected: expectedATAMajorVer},
	}
	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			assert.Equal(t, test.expected, d.getATAMajorVersion())
		})
	}
}

func TestGetATAMinorVersion(t *testing.T) {

	expectedATAMinorVer := "ACS-3 revision 5"

	binary.Read(bytes.NewBuffer(ataCSPage[:]), util.NativeEndian, &d)

	tests := map[string]struct {
		expected string
	}{
		"get ata minor version assuming d.MinorVer as raw data from ATACS page": {expected: expectedATAMinorVer},
	}
	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			assert.Equal(t, test.expected, d.getATAMinorVersion())
		})
	}
}

func TestATATransport(t *testing.T) {

	expectedATATransport := "Serial ATA SATA 3.1"

	binary.Read(bytes.NewBuffer(ataCSPage[:]), util.NativeEndian, &d)

	tests := map[string]struct {
		expected string
	}{
		"get ata transport assuming d.AtaTransportMajor as raw data from ATACS page": {expected: expectedATATransport},
	}
	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			assert.Equal(t, test.expected, d.ataTransport())
		})
	}
}

func TestIdentifySerialATAType(t *testing.T) {

	expectedSerialATAType := "Serial ATA SATA 3.1"

	binary.Read(bytes.NewBuffer(ataCSPage[:]), util.NativeEndian, &d)

	tests := map[string]struct {
		expected string
	}{
		"get serial ata type assuming d.AtaTransportMajor as raw data from ATACS page": {expected: expectedSerialATAType},
	}
	for name, test := range tests {
		t.Run(name, func(t *testing.T) {
			assert.Equal(t, test.expected, d.IdentifySerialATAType())
		})
	}
}
